# 链表相关原理
代码实现：https://github.com/tiancityycf/algorithm/blob/master/linkedcycle.php

1.如何判断是否有环？如果有两个头结点指针，一个走的快（一次走2步），一个走的慢（一次一步），那么若干步以后，快的指针总会超过慢的指针一圈。

2.如何计算环的长度？第一次相遇（超一圈）时开始计数，第二次相遇时停止计数。

3.如何判断环的入口点：碰撞点p到连接点的距离=头指针到连接点的距离，因此，分别从碰撞点、头指针开始走，相遇的那个点就是连接点。
为什么呢？需要一个简单的计算过程：
（1）当fast与slow相遇时，slow肯定没有走完链表，而fast已经在环里走了n（n>= 1）圈。假设slow走了s步，那么fast走了2s步。fast的步数还等于s走的加上环里转的n圈，所以有：
2s = s + nr。因此，s = nr。
（2）设整个链表长为L，入口据相遇点X，起点到入口的距离为a。因为slow指针并没有走完一圈，所以：
a + x = s，带入第一步的结果，有：a + x = nr = (n-1)r + r = (n-1)r + L - a；即：
a = (n-1)r + L -a -x;
这说明：从头结点到入口的距离，等于转了(n-1)圈以后，相遇点到入口的距离。因此，我们可以在链表头、相遇点各设一个指针，每次各走一步，两个指针必定相遇，且相遇第一点为环入口点。

4.如何判断两个链表（不带环）是否相交？
思路：
1、碰到这个问题，第一印象是采用hash来判断，将两个链表的节点进行hash，然后判断出节点，这种想法当然是可以的。
2、当然采用暴力的方法也是可以的，遍历两个链表，在遍历的过程中进行比较，看节点是否相同。
3、第三种思路是比较奇特的，在编程之美上看到的。先遍历第一个链表到他的尾部，然后将尾部的next指针指向第二个链表(尾部指针的next本来指向的是null)。这样两个链表就合成了一个链表，判断原来的两个链表是否相交也就转变成了判断新的链表是否有环的问题了：即判断单链表是否有环？
这样进行转换后就可以从链表头部进行判断了，其实并不用。通过简单的了解我们就很容易知道，如果新链表是有环的，那么原来第二个链表的头部一定在环上。因此我们就可以从第二个链表的头部进行遍历的，从而减少了时间复杂度(减少的时间复杂度是第一个链表的长度)。
4、先计算两个链表的长度L1、L2，若L1 > L2，则先将链表1移动（L1 - L2）个节点，等到链表1和链表2剩下的长度一样的时候，一起向后移动，依次判断当前链表的节点是否相等，若相等，则相交，若到队尾还没有相等的，则不相交

5、有环单链表是否相交的判断方法
先比较两个链表的入环节点是否相等，若想等，则相交，若不想等，则从某个链表的入环节点开始循环一周，判断是否有节点等于另一个链表的入环节点，若等于，则相交，否则不相交。

